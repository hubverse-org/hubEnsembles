#' Helper function for computing ensemble model outputs as a linear pool
#' (distributional mixture) of component model outputs for the `sample`
#' output type.
#'
#' @inheritParams linear_pool
#'
#' @details The resulting output type ID values are character strings, generated by
#'   a concatenation of the component model ID and initial output type ID, unless
#'   the input `model_out_tbl` is detected to have a numeric `output_type_id`
#'   column. In the latter case, a factor representation of this character string
#'   is coerced to a numeric value.
#' @noRd
#'
#' @return a `model_out_tbl` object of ensemble predictions for the `sample`
#' output type. Note that the output type ID values will not match those of the
#' input model_out_tbl but do preserve relationships across combinations of
#' task ID variables.
#'
#' @importFrom rlang .data
linear_pool_sample <- function(model_out_tbl, weights = NULL,
                               weights_col_name = "weight",
                               model_id = "hub-ensemble",
                               task_id_cols = NULL,
                               compound_taskid_set = NULL,
                               n_output_samples = NULL) {

  validate_sample_inputs(model_out_tbl, weights, weights_col_name, compound_taskid_set, n_output_samples)

  num_models <- length(unique(model_out_tbl$model_id))
  if (is.null(weights)) {
    weights <- data.frame(
      model_id = unique(model_out_tbl$model_id),
      weight = 1 / num_models,
      stringsAsFactors = FALSE
    )
    weights_col_name <- "weight"
  }
  weight_by_cols <- colnames(weights)[colnames(weights) != weights_col_name]
  unique_weights <- unique(weights[[weights_col_name]])

  if (length(unique_weights) != 1) {
    cli::cli_abort("{.arg weights} must be {.val NULL} or equal for every model")
  }

  if (!is.null(n_output_samples)) {
    samples_per_combo <- model_out_tbl |>
      dplyr::group_by(dplyr::across(dplyr::all_of(c("model_id", compound_taskid_set)))) |>
      dplyr::summarize(provided_samples = length(unique(.data[["output_type_id"]]))) |>
      dplyr::ungroup() |>
      tidyr::complete(
        !!!rlang::syms(c("model_id", compound_taskid_set)),
        fill = list(provided_samples = 0)
      ) |>
      dplyr::left_join(weights, weight_by_cols) |>
      dplyr::mutate(target_samples = ifelse(
        .data[["provided_samples"]] <= 0,
        0,
        floor(.data[[weights_col_name]] * n_output_samples)
      ))

    if (!is.null(compound_taskid_set)) {
      samples_per_combo <- split(samples_per_combo, f = samples_per_combo[, compound_taskid_set])
    } else {
      samples_per_combo <- list(samples_per_combo)
    }
    # deal with n_output_samples not divisible evenly among component models
    samples_per_combo <- samples_per_combo |>
      purrr::map(.f = function(split_per_combo) {
        valid_models <- split_per_combo$model_id[split_per_combo$provided_samples > 0]
        split_per_combo[[weights_col_name]] <-
          ifelse(split_per_combo$provided_samples == 0, 0, 1 / length(valid_models))
        split_per_combo$target_samples <-
          ifelse(split_per_combo$target_samples == 0, 0, floor(split_per_combo[[weights_col_name]] * n_output_samples))

        actual_output_samples <- split_per_combo |>
          dplyr::group_by(dplyr::across(dplyr::all_of(compound_taskid_set))) |>
          dplyr::summarize(output_samples = sum(.data[["target_samples"]])) |>
          dplyr::pull(.data[["output_samples"]]) |>
          unique()
        remainder_samples <- n_output_samples - actual_output_samples

        models_to_resample <- sample(x = valid_models, size = remainder_samples)
        split_per_combo |>
          dplyr::mutate(target_samples = ifelse(
            model_id %in% models_to_resample, .data[["target_samples"]] + 1, .data[["target_samples"]]
          ))
      }) |>
      purrr::list_rbind()

    if (any(samples_per_combo$provided_samples < samples_per_combo$target_samples)) {
      cli::cli_abort("Requested output samples per compound unit cannot exceed the provided samples per compound unit.")
    }

    split_compound_taskid_set <- model_out_tbl |>
      split(f = model_out_tbl[, c("model_id", compound_taskid_set)])
    model_out_tbl <- split_compound_taskid_set |>
      purrr::map(.f = function(split_outputs) {
        if (nrow(split_outputs) != 0) {
          current_compound_taskid_set <- split_outputs |>
            dplyr::distinct(dplyr::across(dplyr::all_of(compound_taskid_set)), .keep_all = TRUE) |>
            dplyr::left_join(samples_per_combo, by = c("model_id", compound_taskid_set))
          provided_indices <- unique(split_outputs$output_type_id)

          sample_idx <- sample(x = provided_indices, size = current_compound_taskid_set$target_samples, replace = FALSE)
          dplyr::filter(split_outputs, .data[["output_type_id"]] %in% sample_idx)
        }
      }) |>
      purrr::list_rbind()
  }

  model_out_tbl |>
    make_sample_indices_unique() |>
    dplyr::select(-"model_id") |>
    dplyr::mutate(model_id = model_id, .before = 1)
}


#' Make the output type ID values of sample forecasts unique for the same
#' combination of task IDs but different models
#'
#' @param model_out_tbl an object of class `model_out_tbl` with component
#'   model outputs (e.g., predictions).
#'
#' @details The new `output_type_id` column values will follow one of two patterns,
#' depending on whether the column is detected to be numeric:
#'   1. If the output type ID is not numeric (may be a character):
#'      A concatenation of the prediction's model ID and original output type ID
#'   2. If the output type ID is numeric: A numeric representation of the above
#'      pattern rendered as a factor.
#'
#' @return a model_out_tbl object with unique output type ID values for different
#'   models but otherwise identical to the input model_out_tbl.
make_sample_indices_unique <- function(model_out_tbl) {
  numeric_output_type_ids <- is.numeric(model_out_tbl$output_type_id)

  new_indices_outputs <- model_out_tbl |>
    dplyr::mutate(output_type_id = paste0(.data[["model_id"]], .data[["output_type_id"]]))

  if (numeric_output_type_ids) {
    new_indices_outputs |>
      dplyr::mutate(output_type_id = as.integer(factor(.data[["output_type_id"]])))
  } else {
    new_indices_outputs
  }
}


#' Perform simple validations on the inputs used to calculate a linear pool
#' of samples
#'
#' @param model_out_tbl an object of class `model_out_tbl` with component
#'   model outputs (e.g., predictions). May only contain the "sample" output type.
#' @param weights an optional `data.frame` with component model weights. If
#'   provided, it should have a column named `model_id` and a column containing
#'   model weights. Default to `NULL`, which specifies an equally-weighted ensemble
#' @param weights_col_name `character` string naming the column in `weights`
#'   with model weights. Defaults to `"weight"`
#' @param compound_taskid_set `character` vector of the compound task ID variable
#'   set. NULL means all columns' values display dependency while equality to
#'   task_id_cols means that none of the columns' values are dependent.
#'   Defaults to NULL, in which case the task id variables are used.
#' @param n_output_samples `numeric` that specifies how many sample forecasts to
#'   return per unique combination of task IDs. Currently the only supported value
#'   is NULL, in which case all provided component model samples are collected and
#'   returned.
#'
#' @return no return value
#'
#' @noRd
validate_sample_inputs <- function(model_out_tbl, weights = NULL,
                                   weights_col_name = "weight",
                                   compound_taskid_set = NULL,
                                   n_output_samples = NULL) {
  if (!identical(unique(model_out_tbl$output_type), "sample")) {
    cli::cli_abort("{.arg model_out_tbl} should only contain the sample output type")
  }

  if (!is.null(n_output_samples) && !is.numeric(n_output_samples) && trunc(n_output_samples) != n_output_samples) {
    cli::cli_abort("{.arg n_output_samples} must be {.val NULL} or an integer value")
  }

  if (!is.null(weights)) {
    if (is.null(n_output_samples)) {
      cli::cli_abort("Component model weights output samples provided,
                     so a number of ensemble samples {.arg n_output_samples} must be provided")
    }

    if (!all(colnames(weights) %in% c("model_id", compound_taskid_set, weights_col_name))) {
      cli::cli_abort("{.arg weights} may only vary for variables in the {.arg compound_taskid_set}.")
    }
  }
}
